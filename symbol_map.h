#ifndef LE_DISASM_SYMBOL_MAP_H_
#define LE_DISASM_SYMBOL_MAP_H_

#include <iostream>
#include <map>
#include <regex>
#include <string>

#include "type.h"

struct SymbolMap {
    struct Properties final {
        std::string name;
        uint32_t address;
        uint32_t size;
        Type type;

        Properties(uint32_t address_, uint32_t size_, std::string name_, Type type_) {
            address = address_;
            size = size_;
            name = name_;
            type = type_;
        }

        Properties(const Properties &other) { *this = other; }

        Properties(void) {
            address = 0;
            size = 0;
            name = std::string("");
            type = UNKNOWN;
        }
    };

    std::map<uint32_t, SymbolMap::Properties> map;
    std::string file_name;

    std::string escape_symbol_name(std::string name) {
        const std::regex re("[\\[\\]\\?\\(\\)@]{1}");
        return std::regex_replace(name, re, "_");
    }

    std::string get_file_name(std::string path) {
        const size_t last_slash_idx = path.find_last_of("\\/");
        if (std::string::npos != last_slash_idx) {
            path.erase(0, last_slash_idx + 1);
        }

        return path;
    }

    const SymbolMap::Properties *get_map_item(uint32_t address) {
        const std::map<uint32_t, SymbolMap::Properties>::const_iterator item = map.find(address);
        if (map.end() != item) {
            return &item->second;
        }

        return 0;
    }

    uint32_t get_label_type(uint32_t address, Type *label) {
        const std::map<uint32_t, SymbolMap::Properties>::iterator item = map.find(address);
        if (map.end() != item) {
            *label = item->second.type;
            return item->first;
        }
        return 0;
    }

    SymbolMap(std::string &path) {
        std::ifstream is(path, std::ofstream::in);

        if (is.is_open()) {
            file_name = get_file_name(std::string(path));

            /* The map file is generated by IDC script 'generate_map.idc' that
             * can be used in IDA 7.0 Freeware on the flat binary image dump of
             * the analyzed executable.
             *
             * \1 symbol_name   \2 type   \3 start_address   \4 region_size
             */
            const std::regex re("^([^\\s]+)\\s+([^\\s]+)\\s+([0-9a-fA-F]+)\\s+([0-9a-fA-F]+)$");
            std::smatch m;
            std::string line;

            is.seekg(std::ios::beg);

            while (std::getline(is, line)) {
                if (std::regex_match(line, m, re)) {
                    if (m.size() == 5) {
                        std::string name = escape_symbol_name(m[1]);
                        std::string type = m[2];
                        uint32_t address = std::stol(m[3], 0, 16);
                        uint32_t size = std::stol(m[4], 0, 16);

                        if ((type.find("LUT") != std::string::npos) and (size % sizeof(uint32_t) == 0)) {
                            map[address] = Properties(address, size, name, SWITCH);
                        } else if (type.find("FUNC") != std::string::npos) {
                            map[address] = Properties(address, size, name, FUNCTION);
                        } else if (type.find("DATA") != std::string::npos) {
                            map[address] = Properties(address, size, name, DATA);
                        } else if (type.find("ASCII") != std::string::npos) {
                            map[address] = Properties(address, size, name, DATA);
                        }
                    }
                }
            }
            is.close();
        }
    }

    std::string findSymbolName(const uint32_t address) {
        return map.count(address) ? map[address].name : std::string("");
    }

    std::string getFileName() { return file_name; }
};

#endif /* LE_DISASM_SYMBOL_MAP_H_ */
